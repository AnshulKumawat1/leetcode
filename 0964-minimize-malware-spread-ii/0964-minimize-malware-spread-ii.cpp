class Solution {
public:  vector<int>parent; vector<int>size;
    int find(int x) {
        if (x == parent[x])
            return x;     
        return parent[x] = find(parent[x]);
    }

    void Union (int x, int y) {
	    int x_parent = find(x);
	    int y_parent = find(y);
	    if (x_parent == y_parent) 
	        return;
	    if(size[x_parent] > size[y_parent]) {
	        parent[y_parent] = x_parent;
	        size[x_parent]  += size[y_parent];
	    } else if(size[x_parent] < size[y_parent]) {
	        parent[x_parent] = y_parent;
	        size[y_parent]  += size[x_parent];
	    } else {
	        parent[x_parent] = y_parent;
	        size[y_parent]  += size[x_parent];
	    }
	}
    int minMalwareSpread(vector<vector<int>>& grid, vector<int>& in) {
        int n=grid.size();
        parent.resize(n);
        size.resize(n);
        
        sort(in.begin(),in.end()); int ans=in[0]; int maxi=0;
         for(int k=0;k<in.size();k++){
            int node=in[k];
            for (int i = 0; i < n; i++) {
               parent[i] = i;
               size[i] = 1;
                }
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                 if(grid[i][j]==1 && i!=j && i!=node && j!=node){
                    Union(i,j);
                 }  
                }
            }
           int total=n; int def=0; set<int>s;
            for(int l=0;l<in.size();l++){
                  if(in[l]==node) continue;
                  s.insert(find(in[l]));
            }
            for(auto it:s) def+=size[it];
            int safe=total-def; 
            if(maxi<safe){maxi=safe; ans=node;}
            
         }
         return ans;
    }
};